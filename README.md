# 1516
深入Go底层原理，重写Redis中间件实战 | 更新完结
### 微:NoBug1024 


课程介绍：

常见的“Go语法+Web小项目”学习模式，早已不能满足企业对Go开发者的技术要求。本课程深入Go语言内核，通过源码解读和原理剖析，帮你构建系统的开发思维；配合Go语言重写Redis项目实战，带你积累大型项目经验，在理解Redis原理的同时，更深入的掌握Go语言高级技术，一箭双雕！
〖课程目录〗:

- ├──{10}--第10章Go的其他高级特性  
- |   ├──(10.1)--10-6作业：如何使用修改后的runtime源码.pdf  283.36kb
- |   ├──(10.2)--10-7面试题.pdf  51.04kb
- |   ├──[10.1]--10-1如何实现GO调用C代码？.mp4  63.16M
- |   ├──[10.2]--10-2defer的底层原理是怎样的？.mp4  44.52M
- |   ├──[10.3]--10-3recover如何在panic中拯救程序？.mp4  54.41M
- |   ├──[10.4]--10-4GO是怎么实现反射的？.mp4  83.72M
- |   ├──[10.5]--10-5实战：使用反射调用方法.mp4  52.22M
- |   └──[10.6]--10-8本章小结.mp4  13.22M
- ├──{11}--第11章GO实现TCP服务器  
- |   ├──[11.1]--11-1实现最简TCP服务器.mp4  91.15M
- |   ├──[11.2]--11-2实现完善的TCP服务器.mp4  87.71M
- |   ├──[11.3]--11-3实现EchoHandler（一）.mp4  73.53M
- |   ├──[11.4]--11-4实现EchoHandler（二）.mp4  67.39M
- |   └──[11.5]--11-5测试TCP服务器.mp4  43.27M
- |   ├──{12}--第12章GO实现Redis协议解析器  
- |   |   ├──[12.10]--12-10实现readBody.mp4  40.94M
- |   |   ├──[12.11]--12-11实现parser(1).mp4  74.15M
- |   |   ├──[12.12]--12-12实现parser(2).mp4  81.70M
- |   |   ├──[12.13]--12-13实现Connection.mp4  57.07M
- |   |   ├──[12.14]--12-14实现RespHandler(1).mp4  46.97M
- |   |   ├──[12.15]--12-15实现RespHandler(2).mp4  73.59M
- |   |   ├──[12.16]--12-16实现EchoDatabase.mp4  49.20M
- |   |   ├──[12.17]--12-17测试RESP协议解析.mp4  21.99M
- |   |   ├──[12.1]--12-1Redis网络协议详解.mp4  32.14M
- |   |   ├──[12.2]--12-2实现constreply.mp4  84.80M
- |   |   ├──[12.3]--12-3实现errorreply.mp4  52.27M
- |   |   ├──[12.4]--12-4实现自定义reply.mp4  86.92M
- |   |   ├──[12.5]--12-5实现ParseStream.mp4  60.28M
- |   |   ├──[12.6]--12-6实现ReadLine.mp4  81.41M
- |   |   ├──[12.7]--12-7实现ParseMultiBulkHeader.mp4  52.97M
- |   |   └──[12.9]--12-9实现ParseSingleLine.mp4  40.40M
- ├──{13}--第13章GO实现内存数据库iclass=new_tagi  
- |   ├──[13.10]--13-10实现KEYS命令集(三).mp4  34.30M
- |   ├──[13.11]--13-11实现STRING命令集(一).mp4  71.14M
- |   ├──[13.12]--13-12实现STRING命令集(二).mp4  40.09M
- |   ├──[13.13]--13-13实现核心Database(一).mp4  94.39M
- |   ├──[13.14]--13-14实现核心Database(二).mp4  82.40M
- |   ├──[13.1]--13-1定义Dict接口（加片头）.mp4  48.52M
- |   ├──[13.2]--13-2实现SyncDict(一).mp4  60.10M
- |   ├──[13.3]--13-3实现SyncDict(二).mp4  57.12M
- |   ├──[13.4]--13-4定义command结构体.mp4  53.95M
- |   ├──[13.5]--13-5实现DB.Exec.mp4  71.33M
- |   ├──[13.7]--13-7实现PING命令.mp4  18.58M
- |   ├──[13.8]--13-8实现KEYS命令集(一).mp4  75.09M
- |   └──[13.9]--13-9实现KEYS命令集(二).mp4  86.21M
- ├──{14}--第14章GO实现Redis持久化  
- |   ├──[14.2]--14-2实现AddAof.mp4  92.75M
- |   ├──[14.3]--14-3实现HandleAof.mp4  70.08M
- |   ├──[14.4]--14-4实现Aof落盘功能(一).mp4  62.24M
- |   ├──[14.5]--14-5实现Aof落盘功能(二).mp4  36.43M
- |   ├──[14.6]--14-6debug闭包问题.mp4  61.47M
- |   ├──[14.7]--14-7实现Aof恢复(一).mp4  81.35M
- |   └──[14.8]--14-8实现Aof恢复(二).mp4  40.66M
- ├──{15}--第15章GO实现Redis集群  
- |   ├──[15.10]--15-10实现特殊模式的指令.mp4  128.49M
- |   ├──[15.11]--15-11完成ClusterDatabase.mp4  107.44M
- |   ├──[15.1]--15-1详解一致性哈希.mp4  28.45M
- |   ├──[15.2]--15-2定义NodeMap.mp4  60.49M
- |   ├──[15.3]--15-3实现一致性哈希.mp4  80.55M
- |   ├──[15.4]--15-4集群架构讲解.mp4  76.99M
- |   ├──[15.5]--15-5实现连接工厂.mp4  89.93M
- |   ├──[15.6]--15-6初始化ClusterDatabase.mp4  93.19M
- |   ├──[15.7]--15-7操作连接池.mp4  120.77M
- |   ├──[15.8]--15-8实现三种执行模式.mp4  83.29M
- |   └──[15.9]--15-9实现defaultFunc.mp4  78.24M
- ├──{16}--第16章回顾与总结  
- |   └──[16.1]--16-1一切才刚刚开始.mp4  135.80M
- ├──{1}--第1章课程导学与学习指南  
- |   ├──(1.1)--1-1课前必读（不读错过一个亿）.pdf  1.36M
- |   └──[1.1]--1-2Go课程概览.mp4  55.45M
- ├──{2}--第2章Go的开发环境搭建与快速入门  
- |   ├──(2.1)--2-2GO语言超快速入门.pdf  142.07kb
- |   ├──(2.2)--2-3如何安装Go.pdf  136.42kb
- |   ├──(2.3)--2-4GO语言快速入门练习.pdf  52.77kb
- |   └──[2.1]--2-1快速搭建Go学习环境.mp4  80.29M
- ├──{3}--第3章带你重新认识Go语言  
- |   ├──(3.1)--3-7面试题.pdf  41.74kb
- |   ├──(3.2)--3-8本章作业.pdf  36.46kb
- |   ├──[3.1]--3-1为什么要用Go语言？.mp4  28.19M
- |   ├──[3.2]--3-2何为Runtime？.mp4  22.56M
- |   ├──[3.3]--3-3Go程序是如何编译的？.mp4  98.28M
- |   ├──[3.4]--3-4Go程序是如何运行的？.mp4  103.04M
- |   ├──[3.5]--3-5Go语言是面向对象的吗？.mp4  65.52M
- |   └──[3.6]--3-6实战：企业级Go项目包管理方法.mp4  92.24M
- ├──{4}--第4章Go在高并发下的数据结构  
- |   ├──(4.1)--4-14本章作业.pdf  28.26kb
- |   ├──(4.2)--4-15面试题.pdf  46.87kb
- |   ├──[4.10]--4-10接口--隐式更好还是显式更好？(二).mp4  55.99M
- |   ├──[4.11]--4-11nil，空接口，空结构体有什么区别？.mp4  76.39M
- |   ├──[4.12]--4-12实战：内存对齐是如何优化程序效率的？(一).mp4  57.20M
- |   ├──[4.13]--4-13实战：内存对齐是如何优化程序效率的？(二).mp4  98.16M
- |   ├──[4.14]--4-16本章小结.mp4  16.56M
- |   ├──[4.1]--4-1什么变量的大小是0字节？.mp4  94.16M
- |   ├──[4.2]--4-2数组，字符串，切片底层是一样的吗？(一).mp4  109.74M
- |   ├──[4.3]--4-3数组，字符串，切片底层是一样的吗？(二).mp4  93.84M
- |   ├──[4.4]--4-4map：重写Redis能用它吗？(一).mp4  129.76M
- |   ├──[4.5]--4-5map：重写Redis能用它吗？(二).mp4  56.01M
- |   ├──[4.6]--4-6map为什么需要扩容？.mp4  78.62M
- |   ├──[4.7]--4-7怎么解决map的并发问题？(一).mp4  101.39M
- |   ├──[4.8]--4-8怎么解决map的并发问题？(二).mp4  58.10M
- |   └──[4.9]--4-9接口--隐式更好还是显式更好？(一).mp4  82.02M
- ├──{5}--第5章高并发的核心工具：Goroutine协程  
- |   ├──(5.1)--5-9本章作业.pdf  154.12kb
- |   ├──(5.2)--5-10面试题.pdf  45.75kb
- |   ├──[5.1]--5-1为什么要有协程，线程不好用吗？.mp4  33.46M
- |   ├──[5.2]--5-2协程的本质是什么？.mp4  75.80M
- |   ├──[5.3]--5-3协程是如何执行的？(一).mp4  90.84M
- |   ├──[5.4]--5-4协程是如何执行的？(二).mp4  16.99M
- |   ├──[5.5]--5-5为什么要有G-M-P调度模型？.mp4  125.80M
- |   ├──[5.6]--5-6如何实现协程并发？.mp4  107.79M
- |   ├──[5.7]--5-7抢占式调度解决了什么问题？.mp4  88.21M
- |   ├──[5.8]--5-8实战--协程太多有什么问题？.mp4  49.35M
- |   └──[5.9]--5-11本章小结.mp4  12.86M
- ├──{6}--第6章Go高并发下的锁  
- |   ├──(6.1)--6-12本章作业.pdf  52.78kb
- |   ├──(6.2)--6-13面试题.pdf  49.65kb
- |   ├──[6.10]--6-10段代码只能执行一次，怎么实现？.mp4  61.67M
- |   ├──[6.11]--6-11实战：如何排查锁异常问题.mp4  73.96M
- |   ├──[6.1]--6-1锁的基础是什么？(一).mp4  81.34M
- |   ├──[6.2]--6-2锁的基础是什么？(二).mp4  72.52M
- |   ├──[6.3]--6-3互斥锁解决了什么问题？.mp4  68.11M
- |   ├──[6.4]--6-4互斥锁是如何工作的？.mp4  159.95M
- |   ├──[6.5]--6-5锁饥饿怎么办？.mp4  142.81M
- |   ├──[6.6]--6-6只让你看，不让你改，能实现吗？(一).mp4  77.02M
- |   ├──[6.7]--6-7只让你看，不让你改，能实现吗？(二).mp4  98.80M
- |   ├──[6.8]--6-8只让你看，不让你改，能实现吗？(三).mp4  46.51M
- |   └──[6.9]--6-9如何通过WaitGroup互相等待？.mp4  98.08M
- ├──{7}--第7章高并发下的通信方式：Channel管道  
- |   ├──(7.1)--7-6本章作业.pdf  52.78kb
- |   ├──(7.2)--7-7面试题.pdf  57.30kb
- |   ├──[7.1]--7-1为什么要用Channel，共享内存不好用吗？.mp4  72.16M
- |   ├──[7.2]--7-2如何设计高性能Channel？.mp4  85.83M
- |   ├──[7.3]--7-3Channel发送数据的底层原理是什么？.mp4  106.21M
- |   ├──[7.4]--7-4Channel接收数据的底层原理是什么？.mp4  91.24M
- |   ├──[7.5]--7-5实战：非阻塞的Channel怎么做？.mp4  51.78M
- |   └──[7.6]--7-8本章小结.mp4  13.31M
- ├──{8}--第8章高并发应用：TCP网络编程  
- |   ├──(8.1)--8-11本章作业.pdf  65.92kb
- |   ├──(8.2)--8-12面试题.pdf  53.06kb
- |   ├──[8.10]--8-10实战：怎样结合阻塞模型和多路复用？.mp4  58.31M
- |   ├──[8.11]--8-13本章小结.mp4  22.06M
- |   ├──[8.1]--8-1什么是非阻塞IO？(一).mp4  36.76M
- |   ├──[8.2]--8-2什么是非阻塞IO？(二).mp4  39.13M
- |   ├──[8.3]--8-3Go是如何抽象Epoll的？(一).mp4  99.17M
- |   ├──[8.4]--8-4Go是如何抽象Epoll的？(二).mp4  65.38M
- |   ├──[8.5]--8-5NetworkPoller是如何工作的？(一).mp4  87.73M
- |   ├──[8.6]--8-6NetworkPoller是如何工作的？(二).mp4  95.25M
- |   ├──[8.7]--8-7Go是如何抽象Socket的？(一).mp4  120.98M
- |   ├──[8.8]--8-8Go是如何抽象Socket的？(二).mp4  68.03M
- |   └──[8.9]--8-9Go是如何抽象Socket的？(三).mp4  62.40M
- ├──{9}--第9章高并发下的内存模型与垃圾回收  
- |   ├──(9.1)--9-10本章作业.pdf  17.32kb
- |   ├──(9.2)--9-11面试题.pdf  62.87kb
- |   ├──[9.10]--9-12本章小结.mp4  35.69M
- |   ├──[9.1]--9-1为什么说Go的栈在堆上？.mp4  55.13M
- |   ├──[9.2]--9-2协程栈不够用了怎么办？.mp4  76.62M
- |   ├──[9.3]--9-3GO的堆内存结构是怎样的？(1).mp4  131.37M
- |   ├──[9.4]--9-4GO的堆内存结构是怎样的？(2).mp4  134.34M
- |   ├──[9.5]--9-5GO的堆内存结构是怎样的？(3).mp4  101.58M
- |   ├──[9.6]--9-6GO的是如何分配堆内存的？.mp4  118.92M
- |   ├──[9.7]--9-7什么样对象需要垃圾回收？.mp4  66.70M
- |   ├──[9.8]--9-8如何减小GC对性能的影响？.mp4  42.85M
- |   └──[9.9]--9-9实战：如何优化GC效率？.mp4  85.23M
- └──课件  
- |   ├──Go课程大资料  
- |   |   ├──go1.17.7.windows-amd64.msi  124.34M
- |   |   ├──goland-2021.3.exe  394.68M
- |   |   └──netassist5.0.2.zip  548.52kb
- |   ├──chapter10-master.zip  1.06kb
- |   ├──chapter11-master.zip  8.46kb
- |   ├──chapter12-master.zip  16.68kb
- |   ├──chapter13-master.zip  27.64kb
- |   ├──chapter14-master.zip  29.80kb
- |   ├──chapter15-master.zip  37.99kb
- |   ├──chapter16-master.zip  0.54kb
- |   ├──chapter3-master.zip  0.90kb
- |   ├──chapter4-master.zip  1.39kb
- |   ├──chapter5-master.zip  0.80kb
- |   ├──chapter6-master.zip  1.17kb
- |   ├──chapter7-master.zip  0.83kb
- |   ├──chapter8-master.zip  0.77kb
- |   └──chapter9-master.zip  0.71kb
